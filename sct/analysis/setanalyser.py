# -*- coding: utf-8 -*-

"""
Solid Earth Tides (SET) analysis module
"""

import logging

log = logging.getLogger(__name__)

import numpy as np
import os
import subprocess

from arepytools.geometry.conversions import xyz2llh

import sct.external.solid as solid


current_directory = os.getcwd()
solid_tool_directory = os.path.join(current_directory, "sct/external/build_solid")
working_directory = os.path.join(current_directory, "data/working_dir")


class SETAnalyser:
    """SETAnalyser class"""

    def __init__(self, xyz_coordinates):
        """Initialise SETAnalyser object

        :param xyz_coordinates: Calibration target XYZ coordinates as numpy array of size 3x1
        :type xyz_coordinates: numpy.ndarray
        """

        self.xyz_coordinates = xyz_coordinates

    def __generate_set_displacement_file(self, latitude, longitude, acquisition_time):
        """Generate SET displacement file running solid tool as an executable

        :param latitude: Calibration target latitude [deg]
        :type latitude: float
        :param longitude: Calibration target longitude [deg]
        :type longitude: float
        :param acquisition_time: Acquisition time [UTC]
        :type acquisition_time: PreciseDateTime
        :return: Path to SET displacement file
        :rtype: str
        """

        # Move to working directory, where solid tool output file will be written
        os.chdir(working_directory)

        # Prepare inputs
        latitude = latitude / np.pi * 180
        longitude = longitude / np.pi * 180

        set_displacement_file = os.path.join(
            working_directory,
            "solid_"
            + str(acquisition_time.year)
            + "_"
            + str(acquisition_time.month)
            + "_"
            + str(acquisition_time.day_of_the_month)
            + "_"
            + str(latitude)
            + "_"
            + str(longitude)
            + ".txt",
        )
        if os.path.isfile(set_displacement_file):
            return set_displacement_file

        # Call solid tool
        input_arguments = (
            str(acquisition_time.year)
            + "\n"
            + str(acquisition_time.month)
            + "\n"
            + str(acquisition_time.day_of_the_month)
            + "\n"
            + str(latitude)
            + "\n"
            + str(longitude)
            + "\n"
        )
        if os.name == "nt":
            subprocess.run(
                os.path.join(solid_tool_directory, "solid.exe"),
                stdout=subprocess.PIPE,
                input=input_arguments,
                encoding="ascii",
            )
        else:
            raise NotImplementedError  # TODO

        # Rename solid tool output file
        os.rename(os.path.join(working_directory, "solid.txt"), set_displacement_file)

        # Move back to current directory
        os.chdir(current_directory)

        return set_displacement_file

    def __read_set_displacement_file(self, set_displacement_file):
        """Read SET displacement file generated by solid tool run as an executable

        :param set_displacement_file: Path to SET displacement file
        :type set_displacement_file: str
        :return: Tuple: North/East/Up displacements and corresponding times, all as numpy arrays
        :rtype: numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray
        """

        # Read solid tool output file
        with open(set_displacement_file) as file:

            file.readline()
            # line_date = file.readline().split()
            # _, _, _ = int(line_date[-3]), int(line_date[-2]), int(line_date[-1])   # year, month, day

            file.readline()
            # line_latlon = file.readline().split()
            # _, _ = float(line_latlon[-2]), float(line_latlon[-1])   # lat, lon

            lines = file.readlines()
            n_lines = len(lines)
            time = np.zeros(n_lines)
            north_displacement = np.zeros(n_lines)
            east_displacement = np.zeros(n_lines)
            up_displacement = np.zeros(n_lines)
            for l, line in enumerate(lines):
                time[l], north_displacement[l], east_displacement[l], up_displacement[l] = [
                    float(x) for x in line.split()
                ]

        return time, north_displacement, east_displacement, up_displacement

    def __generate_set_displacement(self, latitude, longitude, acquisition_time):
        """Compute SET displacement parameters running solid tool as an external module

        :param latitude: Calibration target latitude [deg]
        :type latitude: float
        :param longitude: Calibration target longitude [deg]
        :type longitude: float
        :param acquisition_time: Acquisition time [UTC]
        :type acquisition_time: PreciseDateTime
        :return: Tuple: North/East/Up displacements and corresponding times, all as numpy arrays
        :rtype: numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray
        """

        # Prepare inputs
        latitude = latitude / np.pi * 180
        longitude = longitude / np.pi * 180

        # Call solid tool
        time, north_displacement, east_displacement, up_displacement = solid.solid(
            latitude, longitude, acquisition_time.year, acquisition_time.month, acquisition_time.day_of_the_month
        )

        return time, north_displacement, east_displacement, up_displacement

    def __get_displacement(self, latitude, longitude, acquisition_time):
        """Get SET displacement parameters

        :param latitude: Calibration target latitude [deg]
        :type latitude: float
        :param longitude: Calibration target longitude [deg]
        :type longitude: float
        :param acquisition_time: Acquisition time [UTC]
        :type acquisition_time: PreciseDateTime
        :return: Tuple: North/East/Up displacements and corresponding times, all as numpy arrays
        :rtype: numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray
        """

        ## Option 1: Use original version of solid tool (executable, writing outputs to file)
        # set_displacement_file = self.__generate_set_displacement_file(latitude, longitude, acquisition_time)
        # time, north_displacement, east_displacement, up_displacement = self.__read_set_displacement_file(set_displacement_file)

        # Option 2: Use updated version of solid tool (library, providing variables in output)
        time, north_displacement, east_displacement, up_displacement = self.__generate_set_displacement(
            latitude, longitude, acquisition_time
        )

        return time, north_displacement, east_displacement, up_displacement

    def get_updated_coordinates(self, acquisition_time):
        """Compute updated calibration target XYZ coordinates after the application of Solid Earth Tides (SET) correction

        :param acquisition_time: Acquisition time [UTC]
        :type acquisition_time: PreciseDateTime
        :return: Calibration target updated XYZ coordinates as numpy array of size 3x1
        :rtype: numpy.ndarray
        """

        # Convert coordinates from geodetic to geocentric
        llh_coordinates = xyz2llh(self.xyz_coordinates)
        lat_geocentric = np.arctan((1 - 1 / 298.25642) ** 2 * np.tan(llh_coordinates[0, :]))

        # Loop over input coordinates
        log.debug("Compute updated target coordinates")
        n_points = self.xyz_coordinates.shape[1]
        xyz_coordinates_updated = np.zeros((3, n_points))
        for p in range(n_points):

            longitude = llh_coordinates[1, p]
            latitude = llh_coordinates[0, p]
            latitude_geocentric = lat_geocentric[p]

            # Compute displacements
            time, north_displacement, east_displacement, up_displacement = self.__get_displacement(
                latitude, longitude, acquisition_time
            )

            # Interpolate displacements in time   # TODO Compute displacement directly at the desired time. Requires update of solid tool
            time_int = (
                acquisition_time.hour_of_day * 3600
                + acquisition_time.minute_of_hour * 60
                + acquisition_time.second_of_minute
            )
            north_displacement_int = np.interp(time_int, time, north_displacement)
            east_displacement_int = np.interp(time_int, time, east_displacement)
            up_displacement_int = np.interp(time_int, time, up_displacement)

            # Compute displacement vectors
            north_versor = np.array(
                [
                    -np.sin(latitude_geocentric) * np.cos(longitude),
                    -np.sin(latitude_geocentric) * np.sin(longitude),
                    np.cos(latitude_geocentric),
                ]
            )
            east_versor = np.array([-np.sin(longitude), np.cos(longitude), 0.0])
            up_versor = np.array(
                [
                    np.cos(latitude_geocentric) * np.cos(longitude),
                    np.cos(latitude_geocentric) * np.sin(longitude),
                    np.sin(latitude_geocentric),
                ]
            )
            displacement_vector = (
                north_displacement_int * north_versor
                + east_displacement_int * east_versor
                + up_displacement_int * up_versor
            )

            # Compute updated coordinates
            xyz_coordinates_updated[:, p] = self.xyz_coordinates[:, p] + displacement_vector

        return xyz_coordinates_updated
