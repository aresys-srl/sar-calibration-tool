# -*- coding: utf-8 -*-

"""
Solid Earth Tides (SET) analysis module
"""

import logging

log = logging.getLogger(__name__)

import numpy as np
import os
import subprocess

from arepytools.geometry.conversions import xyz2llh

import sct.external.solid as solid


current_directory = os.getcwd()
solid_tool_directory = os.path.join(current_directory, "sct/external/build_solid")
working_directory = os.path.join(current_directory, "data/working_dir")


class SETAnalyser:
    """SETAnalyser class"""

    def __init__(self, xyz_coordinates):
        """Initialise SETAnalyser object

        :param xyz_coordinates: Calibration target XYZ coordinates as numpy array of size 3x1
        :type xyz_coordinates: numpy.ndarray
        """

        self.xyz_coordinates = xyz_coordinates

    # def __generate_set_displacement_file(self, latitude, longitude, acquisition_time):
    #     """Generate SET displacement file running solid tool as an executable

    #     :param latitude: Calibration target latitude [deg]
    #     :type latitude: float
    #     :param longitude: Calibration target longitude [deg]
    #     :type longitude: float
    #     :param acquisition_time: Acquisition time [UTC]
    #     :type acquisition_time: PreciseDateTime
    #     :return: Path to SET displacement file
    #     :rtype: str
    #     """

    #     # Move to working directory, where solid tool output file will be written
    #     os.chdir(working_directory)

    #     # Prepare inputs
    #     latitude = latitude / np.pi * 180
    #     longitude = longitude / np.pi * 180

    #     set_displacement_file = os.path.join(
    #         working_directory,
    #         "solid_"
    #         + str(acquisition_time.year)
    #         + "_"
    #         + str(acquisition_time.month)
    #         + "_"
    #         + str(acquisition_time.day_of_the_month)
    #         + "_"
    #         + str(latitude)
    #         + "_"
    #         + str(longitude)
    #         + ".txt",
    #     )
    #     if os.path.isfile(set_displacement_file):
    #         return set_displacement_file

    #     # Call solid tool
    #     input_arguments = (
    #         str(acquisition_time.year)
    #         + "\n"
    #         + str(acquisition_time.month)
    #         + "\n"
    #         + str(acquisition_time.day_of_the_month)
    #         + "\n"
    #         + str(latitude)
    #         + "\n"
    #         + str(longitude)
    #         + "\n"
    #     )
    #     if os.name == "nt":
    #         subprocess.run(
    #             os.path.join(solid_tool_directory, "solid.exe"),
    #             stdout=subprocess.PIPE,
    #             input=input_arguments,
    #             encoding="ascii",
    #         )
    #     else:
    #         raise NotImplementedError  # TODO

    #     # Rename solid tool output file
    #     os.rename(os.path.join(working_directory, "solid.txt"), set_displacement_file)

    #     # Move back to current directory
    #     os.chdir(current_directory)

    #     return set_displacement_file

    # def __read_set_displacement_file(self, set_displacement_file):
    #     """Read SET displacement file generated by solid tool run as an executable

    #     :param set_displacement_file: Path to SET displacement file
    #     :type set_displacement_file: str
    #     :return: Tuple: North/East/Up displacements and corresponding times, all as numpy arrays
    #     :rtype: numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray
    #     """

    #     # Read solid tool output file
    #     with open(set_displacement_file) as file:

    #         file.readline()
    #         # line_date = file.readline().split()
    #         # _, _, _ = int(line_date[-3]), int(line_date[-2]), int(line_date[-1])   # year, month, day

    #         file.readline()
    #         # line_latlon = file.readline().split()
    #         # _, _ = float(line_latlon[-2]), float(line_latlon[-1])   # lat, lon

    #         lines = file.readlines()
    #         n_lines = len(lines)
    #         time = np.zeros(n_lines)
    #         north_displacement = np.zeros(n_lines)
    #         east_displacement = np.zeros(n_lines)
    #         up_displacement = np.zeros(n_lines)
    #         for l, line in enumerate(lines):
    #             time[l], north_displacement[l], east_displacement[l], up_displacement[l] = [
    #                 float(x) for x in line.split()
    #             ]

    #     return time, north_displacement, east_displacement, up_displacement

    def __generate_set_displacement(self, latitude, longitude, acquisition_time):
        """Compute SET displacement parameters running solid tool as an external module

        :param latitude: Calibration target latitude [deg]
        :type latitude: float
        :param longitude: Calibration target longitude [deg]
        :type longitude: float
        :param acquisition_time: Acquisition time [UTC]
        :type acquisition_time: PreciseDateTime
        :return: Tuple: North/East/Up displacements and corresponding times, all as numpy arrays
        :rtype: numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray
        """

        # Prepare inputs
        latitude = latitude / np.pi * 180
        longitude = longitude / np.pi * 180

        # Call solid tool
        time, north_displacement, east_displacement, up_displacement = solid.solid(
            latitude, longitude, acquisition_time.year, acquisition_time.month, acquisition_time.day_of_the_month
        )

        return time, north_displacement, east_displacement, up_displacement

    def __get_displacement(self, latitude, longitude, acquisition_time):
        """Get SET displacement parameters

        :param latitude: Calibration target latitude [deg]
        :type latitude: float
        :param longitude: Calibration target longitude [deg]
        :type longitude: float
        :param acquisition_time: Acquisition time [UTC]
        :type acquisition_time: PreciseDateTime
        :return: Tuple: North/East/Up displacements and corresponding times, all as numpy arrays
        :rtype: numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray
        """

        ## Option 1: Use original version of solid tool (executable, writing outputs to file)
        # set_displacement_file = self.__generate_set_displacement_file(latitude, longitude, acquisition_time)
        # time, north_displacement, east_displacement, up_displacement = self.__read_set_displacement_file(set_displacement_file)

        # Option 2: Use updated version of solid tool (library, providing variables in output)
        time, north_displacement, east_displacement, up_displacement = self.__generate_set_displacement(
            latitude, longitude, acquisition_time
        )

        return time, north_displacement, east_displacement, up_displacement

    def get_updated_coordinates(self, acquisition_time):
        """Compute updated calibration target XYZ coordinates after the application of Solid Earth Tides (SET) correction

        :param acquisition_time: Acquisition time [UTC]
        :type acquisition_time: PreciseDateTime
        :return: Calibration target updated XYZ coordinates as numpy array of size 3x1
        :rtype: numpy.ndarray
        """

        # Convert coordinates from geodetic to geocentric
        llh_coordinates = xyz2llh(self.xyz_coordinates)
        lat_geocentric = np.arctan((1 - 1 / 298.25642) ** 2 * np.tan(llh_coordinates[0, :]))

        # Loop over input coordinates
        log.debug("Compute updated target coordinates")
        n_points = self.xyz_coordinates.shape[1]
        xyz_coordinates_updated = np.zeros((3, n_points))
        for p in range(n_points):

            longitude = llh_coordinates[1, p]
            latitude = llh_coordinates[0, p]
            latitude_geocentric = lat_geocentric[p]

            # Compute displacements
            time, north_displacement, east_displacement, up_displacement = self.__get_displacement(
                latitude, longitude, acquisition_time
            )

            # Interpolate displacements in time   # TODO Compute displacement directly at the desired time. Requires update of solid tool
            time_int = (
                acquisition_time.hour_of_day * 3600
                + acquisition_time.minute_of_hour * 60
                + acquisition_time.second_of_minute
            )
            north_displacement_int = np.interp(time_int, time, north_displacement)
            east_displacement_int = np.interp(time_int, time, east_displacement)
            up_displacement_int = np.interp(time_int, time, up_displacement)

            # Compute displacement vectors
            north_versor = np.array(
                [
                    -np.sin(latitude_geocentric) * np.cos(longitude),
                    -np.sin(latitude_geocentric) * np.sin(longitude),
                    np.cos(latitude_geocentric),
                ]
            )
            east_versor = np.array([-np.sin(longitude), np.cos(longitude), 0.0])
            up_versor = np.array(
                [
                    np.cos(latitude_geocentric) * np.cos(longitude),
                    np.cos(latitude_geocentric) * np.sin(longitude),
                    np.sin(latitude_geocentric),
                ]
            )
            displacement_vector = (
                north_displacement_int * north_versor
                + east_displacement_int * east_versor
                + up_displacement_int * up_versor
            )

            # Compute updated coordinates
            xyz_coordinates_updated[:, p] = self.xyz_coordinates[:, p] + displacement_vector

        return xyz_coordinates_updated
